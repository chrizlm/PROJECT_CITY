"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = require("react");

var _sockjsClient = _interopRequireDefault(require("sockjs-client"));

var _stompjs = _interopRequireDefault(require("stompjs"));

var _difference = _interopRequireDefault(require("lodash/difference"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * React hooks for SockJS-client with STOMP messaging protocol.
 *
 * @see {@link https://stomp.github.io/|STOMP}
 * @see {@link https://github.com/sockjs/sockjs-client|StompJS}
 */
var useSockjs = function useSockjs(props) {
  var _props$onConnect = props.onConnect,
      onConnect = _props$onConnect === void 0 ? function () {} : _props$onConnect,
      _props$onDisconnect = props.onDisconnect,
      onDisconnect = _props$onDisconnect === void 0 ? function () {} : _props$onDisconnect,
      _props$getRetryInterv = props.getRetryInterval,
      getRetryInterval = _props$getRetryInterv === void 0 ? function (count) {
    return 1000 * count;
  } : _props$getRetryInterv,
      _props$onMessage = props.onMessage,
      onMessage = _props$onMessage === void 0 ? function (msg, destination) {} : _props$onMessage,
      _props$options = props.options,
      options = _props$options === void 0 ? {} : _props$options,
      _props$headers = props.headers,
      headers = _props$headers === void 0 ? {} : _props$headers,
      _props$subscribeHeade = props.subscribeHeaders,
      subscribeHeaders = _props$subscribeHeade === void 0 ? {} : _props$subscribeHeade,
      _props$autoReconnect = props.autoReconnect,
      autoReconnect = _props$autoReconnect === void 0 ? true : _props$autoReconnect,
      _props$debug = props.debug,
      debug = _props$debug === void 0 ? false : _props$debug,
      _props$heartbeat = props.heartbeat,
      heartbeat = _props$heartbeat === void 0 ? 10000 : _props$heartbeat;
  var connected = (0, _react.useRef)(false);
  var explicitDisconnect = (0, _react.useRef)(false);
  var topicsRef = (0, _react.useRef)(props.topics);
  var subscriptions = (0, _react.useRef)(new Map()); // 监听

  var retryCount = (0, _react.useRef)(0);
  var timeoutId = (0, _react.useRef)(null);
  var client = (0, _react.useRef)(null); // Websocket实例

  var savedOnMessage = (0, _react.useRef)(onMessage);
  (0, _react.useEffect)(function () {
    savedOnMessage.current = onMessage;
  });

  var _initStompClient = (0, _react.useCallback)(function () {
    // stompjs的Websocket只能打开一次
    client.current = _stompjs.default.over(new _sockjsClient.default(props.url, null, options));
    client.current.heartbeat.outgoing = heartbeat;
    client.current.heartbeat.incoming = heartbeat;

    if (Object.keys(props).includes('heartbeatIncoming')) {
      client.current.heartbeat.incoming = props.heartbeatIncoming;
    }

    if (Object.keys(props).includes('heartbeatOutgoing')) {
      client.current.heartbeat.outgoing = props.heartbeatOutgoing;
    }

    if (!debug) {
      client.current.debug = function () {};
    }
  }, []);

  var _cleanUp = (0, _react.useCallback)(function () {
    connected.current = false;
    client.current = 0;
    retryCount.current = 0;
    subscriptions.current.clear();
  }, []);

  var _log = (0, _react.useCallback)(function (msg) {
    if (debug) {
      console.log(msg);
    }
  }, []);

  var _subscribe = (0, _react.useCallback)(function (topic) {
    if (!subscriptions.current.has(topic)) {
      var sub = client.current.subscribe(topic, function (msg) {
        var body = _processMessage(msg.body);

        savedOnMessage.current(body, msg.headers.destination);

        if (body && body.status === 'END') {
          disconnect();
        }
      }, subscribeHeaders);
      subscriptions.current.set(topic, sub);
    }
  }, []);

  var _processMessage = (0, _react.useCallback)(function (msgBody) {
    try {
      return JSON.parse(msgBody);
    } catch (e) {
      return msgBody;
    }
  }, []);

  var _unsubscribe = (0, _react.useCallback)(function (topic) {
    var sub = subscriptions.current.get(topic);
    sub.unsubscribe();
    subscriptions.current.delete(topic);
  }, []);

  var _connect = (0, _react.useCallback)(function () {
    _initStompClient();

    client.current.connect(headers, function () {
      connected.current = true;
      topicsRef.current.forEach(function (topic) {
        _subscribe(topic);
      });
      onConnect();
    }, function (error) {
      if (error) {
        if (props.onConnectFailure) {
          props.onConnectFailure(error);
        } else {
          _log(error.stack);
        }
      }

      if (connected.current) {
        _cleanUp(); // 对于每个连接，onDisconnect应该只调用一次


        onDisconnect();
      }

      if (autoReconnect && !explicitDisconnect.current) {
        retryCount.current = retryCount.current + 1;
        timeoutId.current = setTimeout(_connect, getRetryInterval(retryCount.current));
      }
    });
  }, []);

  var connect = (0, _react.useCallback)(function () {
    explicitDisconnect.current = false;

    if (!connected.current) {
      _connect();
    }
  }, []);
  var disconnect = (0, _react.useCallback)(function () {
    // 在显式调用disconnect时，不需要重新连接
    // 清除timeoutId，以防组件试图重新连接
    if (timeoutId.current) {
      clearTimeout(timeoutId.current);
      timeoutId.current = null;
    }

    explicitDisconnect.current = true;

    if (connected.current) {
      subscriptions.current.forEach(function (subid, topic) {
        _unsubscribe(topic);
      });
      client.current.disconnect(function () {
        _cleanUp();

        onDisconnect();

        _log('Stomp client is successfully disconnected!');
      });
    }
  }, []);
  var sendMessage = (0, _react.useCallback)(function (topic, msg) {
    var optHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (connected.current) {
      client.current.send(topic, optHeaders, msg);
    } else {
      throw new Error('Send error: SockJsClient is disconnected');
    }
  }, []);
  var sendJsonMessage = (0, _react.useCallback)(function (topic, msg) {
    var optHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    sendMessage(topic, JSON.stringify(msg), optHeaders);
  }, [sendMessage]);
  (0, _react.useEffect)(function () {
    if (connected.current) {
      // 订阅新topics
      (0, _difference.default)(props.topics, topicsRef.current).forEach(function (newTopic) {
        _log('Subscribing to topic: ' + newTopic);

        _subscribe(newTopic);
      }); // 取消订阅topics

      (0, _difference.default)(topicsRef.current, props.topics).forEach(function (oldTopic) {
        _log('Unsubscribing from topic: ' + oldTopic);

        _unsubscribe(oldTopic);
      });
      topicsRef.current = props.topics;
    }
  }, [props.topics]);
  (0, _react.useEffect)(function () {
    _connect();

    return function () {
      return disconnect();
    };
  }, []);
  return {
    connect: connect,
    disconnect: disconnect,
    sendMessage: sendMessage,
    sendJsonMessage: sendJsonMessage,
    client: client.current
  };
};

var _default = useSockjs;
exports.default = _default;