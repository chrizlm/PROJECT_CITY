/**
 * React hooks for SockJS-client with STOMP messaging protocol.
 *
 * @see {@link https://stomp.github.io/|STOMP}
 * @see {@link https://github.com/sockjs/sockjs-client|StompJS}
 */
import { useRef, useEffect, useCallback } from 'react';
import SockJS from 'sockjs-client';
import Stomp from 'stompjs';
import difference from 'lodash/difference';

var useSockjs = function useSockjs(props) {
  var _props$onConnect = props.onConnect,
      onConnect = _props$onConnect === void 0 ? function () {} : _props$onConnect,
      _props$onDisconnect = props.onDisconnect,
      onDisconnect = _props$onDisconnect === void 0 ? function () {} : _props$onDisconnect,
      _props$getRetryInterv = props.getRetryInterval,
      getRetryInterval = _props$getRetryInterv === void 0 ? function (count) {
    return 1000 * count;
  } : _props$getRetryInterv,
      _props$onMessage = props.onMessage,
      onMessage = _props$onMessage === void 0 ? function (msg, destination) {} : _props$onMessage,
      _props$options = props.options,
      options = _props$options === void 0 ? {} : _props$options,
      _props$headers = props.headers,
      headers = _props$headers === void 0 ? {} : _props$headers,
      _props$subscribeHeade = props.subscribeHeaders,
      subscribeHeaders = _props$subscribeHeade === void 0 ? {} : _props$subscribeHeade,
      _props$autoReconnect = props.autoReconnect,
      autoReconnect = _props$autoReconnect === void 0 ? true : _props$autoReconnect,
      _props$debug = props.debug,
      debug = _props$debug === void 0 ? false : _props$debug,
      _props$heartbeat = props.heartbeat,
      heartbeat = _props$heartbeat === void 0 ? 10000 : _props$heartbeat;
  var connected = useRef(false);
  var explicitDisconnect = useRef(false);
  var topicsRef = useRef(props.topics);
  var subscriptions = useRef(new Map()); // 监听

  var retryCount = useRef(0);
  var timeoutId = useRef(null);
  var client = useRef(null); // Websocket实例

  var savedOnMessage = useRef(onMessage);
  useEffect(function () {
    savedOnMessage.current = onMessage;
  });

  var _initStompClient = useCallback(function () {
    // stompjs的Websocket只能打开一次
    client.current = Stomp.over(new SockJS(props.url, null, options));
    client.current.heartbeat.outgoing = heartbeat;
    client.current.heartbeat.incoming = heartbeat;

    if (Object.keys(props).includes('heartbeatIncoming')) {
      client.current.heartbeat.incoming = props.heartbeatIncoming;
    }

    if (Object.keys(props).includes('heartbeatOutgoing')) {
      client.current.heartbeat.outgoing = props.heartbeatOutgoing;
    }

    if (!debug) {
      client.current.debug = function () {};
    }
  }, []);

  var _cleanUp = useCallback(function () {
    connected.current = false;
    client.current = 0;
    retryCount.current = 0;
    subscriptions.current.clear();
  }, []);

  var _log = useCallback(function (msg) {
    if (debug) {
      console.log(msg);
    }
  }, []);

  var _subscribe = useCallback(function (topic) {
    if (!subscriptions.current.has(topic)) {
      var sub = client.current.subscribe(topic, function (msg) {
        var body = _processMessage(msg.body);

        savedOnMessage.current(body, msg.headers.destination);

        if (body && body.status === 'END') {
          disconnect();
        }
      }, subscribeHeaders);
      subscriptions.current.set(topic, sub);
    }
  }, []);

  var _processMessage = useCallback(function (msgBody) {
    try {
      return JSON.parse(msgBody);
    } catch (e) {
      return msgBody;
    }
  }, []);

  var _unsubscribe = useCallback(function (topic) {
    var sub = subscriptions.current.get(topic);
    sub.unsubscribe();
    subscriptions.current.delete(topic);
  }, []);

  var _connect = useCallback(function () {
    _initStompClient();

    client.current.connect(headers, function () {
      connected.current = true;
      topicsRef.current.forEach(function (topic) {
        _subscribe(topic);
      });
      onConnect();
    }, function (error) {
      if (error) {
        if (props.onConnectFailure) {
          props.onConnectFailure(error);
        } else {
          _log(error.stack);
        }
      }

      if (connected.current) {
        _cleanUp(); // 对于每个连接，onDisconnect应该只调用一次


        onDisconnect();
      }

      if (autoReconnect && !explicitDisconnect.current) {
        retryCount.current = retryCount.current + 1;
        timeoutId.current = setTimeout(_connect, getRetryInterval(retryCount.current));
      }
    });
  }, []);

  var connect = useCallback(function () {
    explicitDisconnect.current = false;

    if (!connected.current) {
      _connect();
    }
  }, []);
  var disconnect = useCallback(function () {
    // 在显式调用disconnect时，不需要重新连接
    // 清除timeoutId，以防组件试图重新连接
    if (timeoutId.current) {
      clearTimeout(timeoutId.current);
      timeoutId.current = null;
    }

    explicitDisconnect.current = true;

    if (connected.current) {
      subscriptions.current.forEach(function (subid, topic) {
        _unsubscribe(topic);
      });
      client.current.disconnect(function () {
        _cleanUp();

        onDisconnect();

        _log('Stomp client is successfully disconnected!');
      });
    }
  }, []);
  var sendMessage = useCallback(function (topic, msg) {
    var optHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (connected.current) {
      client.current.send(topic, optHeaders, msg);
    } else {
      throw new Error('Send error: SockJsClient is disconnected');
    }
  }, []);
  var sendJsonMessage = useCallback(function (topic, msg) {
    var optHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    sendMessage(topic, JSON.stringify(msg), optHeaders);
  }, [sendMessage]);
  useEffect(function () {
    if (connected.current) {
      // 订阅新topics
      difference(props.topics, topicsRef.current).forEach(function (newTopic) {
        _log('Subscribing to topic: ' + newTopic);

        _subscribe(newTopic);
      }); // 取消订阅topics

      difference(topicsRef.current, props.topics).forEach(function (oldTopic) {
        _log('Unsubscribing from topic: ' + oldTopic);

        _unsubscribe(oldTopic);
      });
      topicsRef.current = props.topics;
    }
  }, [props.topics]);
  useEffect(function () {
    _connect();

    return function () {
      return disconnect();
    };
  }, []);
  return {
    connect: connect,
    disconnect: disconnect,
    sendMessage: sendMessage,
    sendJsonMessage: sendJsonMessage,
    client: client.current
  };
};

export default useSockjs;